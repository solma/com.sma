package com.shuoma.alg.number;
/**
 * use Tournament tree to find kth minimum element
 * source: https://blogs.oracle.com/malkit/entry/finding_kth_minimum_partial_ordering
 */

/**
 * Copyright (c) 2010-2020 Malkit S. Bhasin. All rights reserved.
 * 
 * All source code and material on this Blog site is the copyright of Malkit S.
 * Bhasin, 2010 and is protected under copyright laws of the United States. This
 * source code may not be hosted on any other site without my express, prior,
 * written permission. Application to host any of the material elsewhere can be
 * made by contacting me at mbhasin at gmail dot com
 * 
 * I have made every effort and taken great care in making sure that the source
 * code and other content included on my web site is technically accurate, but I
 * disclaim any and all responsibility for any loss, damage or destruction of
 * data or any other property which may arise from relying on it. I will in no
 * case be liable for any monetary damages arising from such loss, damage or
 * destruction.
 * 
 * I further grant you ("Licensee") a non-exclusive, royalty free, license to
 * use, modify and redistribute this software in source and binary code form,
 * provided that i) this copyright notice and license appear on all copies of
 * the software;
 * 
 * As with any code, ensure to test this code in a development environment
 * before attempting to run it in production.
 * 
 * @author Malkit S. Bhasin
 * 
 */

public class KThMinimum {

	/**
	 * @param inputArray
	 *            unordered array of non-negative integers
	 * @param k
	 *            order of minimum value desired
	 * @return kth minimum value
	 */
	public static int getKthMinimum(int[] inputArray, int k) {
		return findKthMinimum(inputArray, k)[k - 1];
	}

	/**
	 * @param inputArray
	 *            unordered array of non-negative integers
	 * @param k
	 *            ordered number of minimum values
	 * @return k ordered minimum values
	 */
	public static int[] getMinimumKSortedElements(int[] inputArray, int k) {
		return findKthMinimum(inputArray, k);
	}

	/**
	 * First output tree will be obtained using tournament method. For k
	 * minimum, the output tree will be backtracked k-1 times for each sub tree
	 * identified by the minimum value in the aggregate adjacency list obtained
	 * from each run. The minimum value after each run will be recorded and
	 * successive runs will produce next minimum value.
	 * 
	 * @param inputArray
	 * @param k
	 * @return ordered array of k minimum elements
	 */
	private static int[] findKthMinimum(int[] inputArray, int k) {
		int[] partiallySorted = new int[k];
		int[][] outputTree = getOutputTree(inputArray);
		int root = getRootElement(outputTree);
		partiallySorted[0] = root;
		int rootIndex = 0;
		int level = outputTree.length;
		int[][][] fullAdjacencyList = new int[k - 1][][];
		int[] kthMinIdx = null;
		for (int i = 1; i < k; i++) {
			fullAdjacencyList[i - 1] = getAdjacencyList(outputTree, root,
					level, rootIndex);
			kthMinIdx = getKthMinimum(fullAdjacencyList, i, root);
			int row = kthMinIdx[0];
			int column = kthMinIdx[1];
			root = fullAdjacencyList[row][column][0];
			partiallySorted[i] = root;
			level = column + 1;
			rootIndex = fullAdjacencyList[row][column][1];
		}

		return partiallySorted;
	}

	/**
	 * Takes an input array and generated a two-dimensional array whose rows are
	 * generated by comparing adjacent elements and selecting minimum of two
	 * elements. Thus the output is inverse triangle (root at bottom)
	 * 
	 * @param values
	 * @return
	 */
	public static int[][] getOutputTree(int[] values) {
		Integer size = new Integer(values.length);
		double treeDepth = Math.log(size.doubleValue()) / Math.log(2);
		// int intTreeDepth = getIntValue(Math.ceil(treeDepth)) + 1;
		int intTreeDepth = (int) (Math.ceil(treeDepth)) + 1;
		int[][] outputTree = new int[intTreeDepth][];

		// first row is the input
		outputTree[0] = values;
		printRow(outputTree[0]);

		int[] currentRow = values;
		int[] nextRow = null;
		for (int i = 1; i < intTreeDepth; i++) {
			nextRow = getNextRow(currentRow);
			outputTree[i] = nextRow;
			currentRow = nextRow;
			printRow(outputTree[i]);
		}
		return outputTree;
	}

	/**
	 * Compares adjacent elements (starting from index 0), and construct a new
	 * array with elements that are smaller of the adjacent elements.
	 * 
	 * For even sized input, the resulting array is half the size, for odd size
	 * array, it is half + 1.
	 * 
	 * @param values
	 * @return
	 */
	private static int[] getNextRow(int[] values) {
		int rowSize = getNextRowSize(values);
		int[] row = new int[rowSize];
		int i = 0;
		for (int j = 0; j < values.length; j++) {
			if (j == (values.length - 1)) {
				// this is the case where there are odd number of elements
				// in the array. Hence the last loop will have only one element.
				row[i++] = values[j];
			} else {
				row[i++] = getMin(values[j], values[++j]);
			}
		}
		return row;
	}

	/**
	 * From the passed full adjacency list and min value scans the list and
	 * returns the information about next minimum value. It returns int array
	 * with two values:
	 * first value: index of the back-track (the min value was found in the
	 * Adjacency list for min value, second min etc.)
	 * second value: index within the identified run.
	 * 
	 * @param fullAdjacencyList
	 *            Adjacency list obtained after k-1 backtracks
	 * @param kth
	 *            Order of minimum value desired
	 * @param kMinusOneMin
	 *            value of k-1 min element
	 * @return
	 */
	private static int[] getKthMinimum(int[][][] fullAdjacencyList, int kth,
			int kMinusOneMin) {
		int kThMin = Integer.MAX_VALUE;
		int[] minIndex = new int[2];
		int j = 0, k = 0;
		int temp = -1;

		for (int i = 0; i < kth; i++) {
			for (j = 0; j < fullAdjacencyList.length; j++) {
				int[][] row = fullAdjacencyList[j];
				if (row != null) {
					for (k = 0; k < fullAdjacencyList[j].length; k++) {
						temp = fullAdjacencyList[j][k][0];
						if (temp <= kMinusOneMin) {
							continue;
						}
						if ((temp > kMinusOneMin) && (temp < kThMin)) {
							kThMin = temp;
							minIndex[0] = j;
							minIndex[1] = k;
						}
					}
				}
			}
		}
		return minIndex;
	}

	/**
	 * Back-tracks a sub-tree (specified by the level and index) parameter and
	 * returns array of elements (during back-track path) along with their index
	 * information. The order elements of output array indicate the level at
	 * which these elements were found (with elements closest to the root at the
	 * end of the list)
	 * 
	 * Starting from root element (which is minimum element), find the lower of
	 * two adjacent element one row above. One of the two element must be root
	 * element. If the root element is left adjacent, the root index (for one
	 * row above) is two times the root index of any row. For right-adjacent, it
	 * is two times plus one. Select the other element (of two adjacent
	 * elements) as second minimum.
	 * 
	 * Then move to one row further up and find elements adjacent to lowest
	 * element, again, one of the element must be root element (again, depending
	 * upon the fact that it is left or right adjacent, you can derive the root
	 * index for this row). Compare the other element with the second least
	 * selected in previous step, select the lower of the two and update the
	 * second lowest with this value.
	 * 
	 * Continue this till you exhaust all the rows of the tree.
	 * 
	 * @param tree
	 *            output tree
	 * @param rootElement
	 *            root element (could be of sub-tree or outputtree)
	 * @param level
	 *            the level to find the root element. For the output tree the
	 *            level is depth of the tree.
	 * @param rootIndex
	 *            index for the root element. For output tree it is 0
	 * @return
	 */
	public static int[][] getAdjacencyList(int[][] tree, int rootElement,
			int level, int rootIndex) {
		int[][] adjacencyList = new int[level - 1][2];
		int adjacentleftElement = -1, adjacentRightElement = -1;
		int adjacentleftIndex = -1, adjacentRightIndex = -1;
		int[] rowAbove = null;

		// we have to scan in reverse order
		for (int i = level - 1; i > 0; i--) {
			// one row above
			rowAbove = tree[i - 1];
			adjacentleftIndex = rootIndex * 2;
			adjacentleftElement = rowAbove[adjacentleftIndex];

			// the root element could be the last element carried from row above
			// because of odd number of elements in array, you need to do
			// following
			// check. if you don't, this case will blow {8, 4, 5, 6, 1, 2}
			if (rowAbove.length >= ((adjacentleftIndex + 1) + 1)) {
				adjacentRightIndex = adjacentleftIndex + 1;
				adjacentRightElement = rowAbove[adjacentRightIndex];
			} else {
				adjacentRightElement = -1;
			}

			// if there is no right adjacent value, then adjacent left must be
			// root continue the loop.
			if (adjacentRightElement == -1) {
				// just checking for error condition
				if (adjacentleftElement != rootElement) {
					throw new RuntimeException(
							"This is error condition. Since there "
									+ " is only one adjacent element (last element), "
									+ " it must be root element");
				} else {
					rootIndex = rootIndex * 2;
					adjacencyList[level - 1][0] = -1;
					adjacencyList[level - 1][1] = -1;
					continue;
				}
			}

			// one of the adjacent number must be root (min value).
			// Get the other number and compared with second min so far
			if (adjacentleftElement == rootElement
					&& adjacentRightElement != rootElement) {
				rootIndex = rootIndex * 2;
				adjacencyList[i - 1][0] = adjacentRightElement;
				adjacencyList[i - 1][1] = rootIndex + 1;
			} else if (adjacentleftElement != rootElement
					&& adjacentRightElement == rootElement) {
				rootIndex = rootIndex * 2 + 1;
				adjacencyList[i - 1][0] = adjacentleftElement;
				adjacencyList[i - 1][1] = rootIndex - 1;
			} else if (adjacentleftElement == rootElement
					&& adjacentRightElement == rootElement) {
				// This is case where the root element is repeating, we are not
				// handling this case.
				throw new RuntimeException(
						"Duplicate Elements. This code assumes no repeating elements in the input array");
			} else {
				throw new RuntimeException(
						"This is error condition. One of the adjacent "
								+ "elements must be root element");
			}
		}

		return adjacencyList;
	}

	/**
	 * Returns minimum of two passed in values.
	 * 
	 * @param num1
	 * @param num2
	 * @return
	 */
	private static int getMin(int num1, int num2) {
		return Math.min(num1, num2);
	}

	/**
	 * following uses Math.ceil(double) to round to upper integer value..since
	 * this function takes double value, diving an int by double results in
	 * double.
	 * 
	 * Another way of achieving this is for number x divided by n would be -
	 * (x+n-1)/n
	 * 
	 * @param values
	 * @return
	 */
	private static int getNextRowSize(int[] values) {
		return (int) Math.ceil(values.length / 2.0);
	}

	/**
	 * Returns the root element of the two-dimensional array.
	 * 
	 * @param tree
	 * @return
	 */
	public static int getRootElement(int[][] tree) {
		int depth = tree.length;
		return tree[depth - 1][0];
	}

	private static void printRow(int[] values) {
		for (int i : values) {
			// System.out.print(i + " ");
		}
		// System.out.println(" ");
	}

	public static void main(String args[]) {
		int[] input = { 2, 14, 5, 13, 1, 8, 17, 10, 6, 12, 9, 4, 11, 15, 3, 16 };
		System.out.println("Fifth Minimum: " + getKthMinimum(input, 5));

		int minimumSortedElementSize = 10;
		int[] tenMinimum = getMinimumKSortedElements(input,
				minimumSortedElementSize);
		System.out.print("Minimum " + minimumSortedElementSize + " Sorted: ");
		for (int i = 0; i < tenMinimum.length; i++) {
			System.out.print(tenMinimum[i] + " ");
		}
	}
}
